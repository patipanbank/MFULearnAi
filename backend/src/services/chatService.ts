import { ChatModel, Chat, ChatMessage } from '../models/chat';
import { wsManager } from '../utils/websocketManager';
import { agentService } from './agentService';
import { usageService } from './usageService';

export class ChatService {
  constructor() {
    console.log('‚úÖ Chat service initialized');
  }

  public async createChat(userId: string, name: string, agentId?: string): Promise<Chat> {
    const chat = new ChatModel({
      userId,
      name,
      messages: [],
      agentId,
      isPinned: false,
      createdAt: new Date(),
      updatedAt: new Date()
    });

    await chat.save();
    console.log(`‚úÖ Created chat session ${chat._id} for user ${userId}`);
    return chat;
  }

  public async getChat(chatId: string, userId: string): Promise<Chat | null> {
    return await ChatModel.findOne({ _id: chatId, userId });
  }

  public async addMessage(chatId: string, message: Omit<ChatMessage, 'id' | 'timestamp'>): Promise<ChatMessage> {
    const chat = await ChatModel.findById(chatId);
    if (!chat) {
      throw new Error(`Chat session ${chatId} not found`);
    }

    const newMessage: ChatMessage = {
      id: Math.random().toString(36).substr(2, 9),
      ...message,
      timestamp: new Date()
    };

    chat.messages.push(newMessage);
    chat.updatedAt = new Date();
    await chat.save();

    console.log(`‚úÖ Added message to session ${chatId}`);

    return newMessage;
  }

  public async processMessage(chatId: string, userId: string, content: string, images?: Array<{ url: string; mediaType: string }>): Promise<void> {
    try {
      // Add user message
      const userMessage = await this.addMessage(chatId, {
        role: 'user',
        content,
        images
      });

      // Send user message to all clients in the session
      // Only broadcast if there are active connections
      if (wsManager.getSessionConnectionCount(chatId) > 0) {
        wsManager.broadcastToSession(chatId, JSON.stringify({
          type: 'user_message',
          data: {
            message: userMessage,
            sessionId: chatId
          }
        }));
      }

      // Get chat and agent info
      const chat = await ChatModel.findById(chatId);
      if (!chat) {
        throw new Error(`Chat session ${chatId} not found`);
      }

      // Process with AI agent
      await this.processWithAI(chatId, content, images, chat.agentId, userId);

    } catch (error) {
      console.error('‚ùå Error processing message:', error);
      
      // Send error to client
      if (wsManager.getSessionConnectionCount(chatId) > 0) {
        wsManager.broadcastToSession(chatId, JSON.stringify({
          type: 'error',
          data: 'Failed to process message'
        }));
      }
    }
  }

  private async processWithAI(chatId: string, userMessage: string, images?: Array<{ url: string; mediaType: string }>, agentId?: string, userId?: string): Promise<void> {
    const chat = await ChatModel.findById(chatId);
    if (!chat) {
      throw new Error(`Chat session ${chatId} not found`);
    }

    // Create assistant message with placeholder content
    const assistantMessage = await this.addMessage(chatId, {
      role: 'assistant',
      content: '‡∏Å‡∏≥‡∏•‡∏±‡∏á‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•...',
      toolUsage: []
    });

          // Send initial assistant message
      if (wsManager.getSessionConnectionCount(chatId) > 0) {
        wsManager.broadcastToSession(chatId, JSON.stringify({
          type: 'assistant_start',
          data: {
            messageId: assistantMessage.id,
            sessionId: chatId
          }
        }));
      }

    // Get agent configuration if available
    let agentConfig = null;
    if (agentId) {
      agentConfig = await agentService.getAgentById(agentId);
    }

    // Simulate AI processing with enhanced features
    await this.simulateAIProcessing(chatId, assistantMessage.id, userMessage, images, agentConfig, userId);
  }

  private async simulateAIProcessing(chatId: string, messageId: string, userMessage: string, images?: Array<{ url: string; mediaType: string }>, agentConfig?: any, userId?: string): Promise<void> {
    // Simulate thinking time
    await this.delay(1000);

    // Simulate tool usage based on message content
    const toolsUsed = await this.simulateToolUsage(chatId, messageId, userMessage, agentConfig);

    // Generate response based on agent configuration
    const response = this.generateResponse(userMessage, images, agentConfig, toolsUsed);
    
    // Stream response with enhanced features
    await this.streamResponse(chatId, messageId, response);

    // Calculate tokens and update usage
    const inputTokens = Math.floor(userMessage.length / 4);
    const outputTokens = Math.floor(response.length / 4);
    
    // Update usage statistics if userId is available
    if (userId) {
      await usageService.updateUsage(userId, inputTokens, outputTokens);
    }

    // Mark as complete
    if (wsManager.getSessionConnectionCount(chatId) > 0) {
      wsManager.broadcastToSession(chatId, JSON.stringify({
        type: 'end',
        data: {
          messageId,
          sessionId: chatId,
          inputTokens,
          outputTokens
        }
      }));
    }
  }

  private async simulateToolUsage(chatId: string, messageId: string, userMessage: string, agentConfig?: any): Promise<string[]> {
    const toolsUsed: string[] = [];
    
    // Simulate different tools based on message content
    if (userMessage.toLowerCase().includes('search') || userMessage.toLowerCase().includes('find')) {
      toolsUsed.push('web_search');
      await this.simulateToolExecution(chatId, messageId, 'web_search', 'Searching for information...', 'Found relevant information about the topic.');
    }
    
    if (userMessage.toLowerCase().includes('calculate') || userMessage.toLowerCase().includes('math')) {
      toolsUsed.push('calculator');
      await this.simulateToolExecution(chatId, messageId, 'calculator', 'Performing calculation...', 'Calculation completed successfully.');
    }
    
    if (userMessage.toLowerCase().includes('knowledge') || userMessage.toLowerCase().includes('database')) {
      toolsUsed.push('knowledge_base');
      await this.simulateToolExecution(chatId, messageId, 'knowledge_base', 'Searching knowledge base...', 'Retrieved relevant information from knowledge base.');
    }

    return toolsUsed;
  }

  private async simulateToolExecution(chatId: string, messageId: string, toolName: string, input: string, output: string): Promise<void> {
    // Send tool start
    if (wsManager.getSessionConnectionCount(chatId) > 0) {
      wsManager.broadcastToSession(chatId, JSON.stringify({
        type: 'tool_start',
        data: {
          messageId,
          tool_name: toolName,
          tool_input: input,
          timestamp: new Date()
        }
      }));
    }

    await this.delay(500);

    // Send tool result
    if (wsManager.getSessionConnectionCount(chatId) > 0) {
      wsManager.broadcastToSession(chatId, JSON.stringify({
        type: 'tool_result',
        data: {
          messageId,
          tool_name: toolName,
          output: output,
          timestamp: new Date()
        }
      }));
    }

    await this.delay(300);
  }

  private async streamResponse(chatId: string, messageId: string, response: string): Promise<void> {
    const words = response.split(' ');
    let fullContent = '';
    
    for (let i = 0; i < words.length; i++) {
      const chunk = (i > 0 ? ' ' : '') + words[i];
      fullContent += chunk;
      
      // Update message content in database
      await ChatModel.updateOne(
        { _id: chatId, 'messages.id': messageId },
        { 
          $set: { 
            'messages.$.content': fullContent,
            updatedAt: new Date()
          }
        }
      );
      
      if (wsManager.getSessionConnectionCount(chatId) > 0) {
        wsManager.broadcastToSession(chatId, JSON.stringify({
          type: 'chunk',
          data: {
            messageId,
            chunk,
            fullContent
          }
        }));
      }

      await this.delay(100);
    }
  }

  private generateResponse(userMessage: string, images?: Array<{ url: string; mediaType: string }>, agentConfig?: any, toolsUsed?: string[]): string {
    // Use agent-specific response if available
    if (agentConfig?.systemPrompt) {
      const responses = [
        `‡∏ï‡∏≤‡∏°‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡πÉ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö: ${agentConfig.systemPrompt}\n\n‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏° "${userMessage}" ‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö:`,
        `‡∏ï‡∏≤‡∏°‡πÅ‡∏ô‡∏ß‡∏ó‡∏≤‡∏á‡∏Ç‡∏≠‡∏á ${agentConfig.name || 'AI Assistant'}: ${agentConfig.systemPrompt}\n\n‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö "${userMessage}":`
      ];
      
      const baseResponse = responses[Math.floor(Math.random() * responses.length)];
      return `${baseResponse} ${this.generateDetailedResponse(toolsUsed)}`;
    }

    // Default responses
    const responses = [
      `‡∏â‡∏±‡∏ô‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Å‡∏±‡∏ö "${userMessage}" ‡πÅ‡∏•‡πâ‡∏ß ‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏ó‡∏µ‡πà‡∏Ñ‡∏£‡∏≠‡∏ö‡∏Ñ‡∏•‡∏∏‡∏°:`,
      `‡∏Ç‡∏≠‡∏ö‡∏Ñ‡∏∏‡∏ì‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏° "${userMessage}" ‡∏â‡∏±‡∏ô‡∏à‡∏∞‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡πÉ‡∏´‡πâ‡∏Ñ‡∏∏‡∏ì‡∏ü‡∏±‡∏á:`,
      `‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏° "${userMessage}" ‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á:`,
      `‡∏â‡∏±‡∏ô‡πÑ‡∏î‡πâ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏° "${userMessage}" ‡∏Ç‡∏≠‡∏á‡∏Ñ‡∏∏‡∏ì‡πÅ‡∏•‡πâ‡∏ß ‡πÅ‡∏•‡∏∞‡∏ô‡∏µ‡πà‡∏Ñ‡∏∑‡∏≠‡∏™‡∏¥‡πà‡∏á‡∏ó‡∏µ‡πà‡∏â‡∏±‡∏ô‡∏û‡∏ö:`
    ];

    const baseResponse = responses[Math.floor(Math.random() * responses.length)];
    
    if (images && images.length > 0) {
      return `${baseResponse} ‡∏â‡∏±‡∏ô‡πÄ‡∏´‡πá‡∏ô‡∏ß‡πà‡∏≤‡∏Ñ‡∏∏‡∏ì‡πÑ‡∏î‡πâ‡πÅ‡∏ô‡∏ö‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡∏°‡∏≤‡∏î‡πâ‡∏ß‡∏¢ ‡∏â‡∏±‡∏ô‡∏à‡∏∞‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏ó‡∏±‡πâ‡∏á‡∏Ç‡πâ‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏•‡∏∞‡∏£‡∏π‡∏õ‡∏†‡∏≤‡∏û‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏ó‡∏µ‡πà‡∏Ñ‡∏£‡∏ö‡∏ñ‡πâ‡∏ß‡∏ô‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î. ${this.generateDetailedResponse(toolsUsed)}`;
    }

    return `${baseResponse} ${this.generateDetailedResponse(toolsUsed)}`;
  }

  private generateDetailedResponse(toolsUsed?: string[]): string {
    let toolInfo = '';
    if (toolsUsed && toolsUsed.length > 0) {
      toolInfo = `‡∏â‡∏±‡∏ô‡πÑ‡∏î‡πâ‡πÉ‡∏ä‡πâ‡πÄ‡∏Ñ‡∏£‡∏∑‡πà‡∏≠‡∏á‡∏°‡∏∑‡∏≠ ${toolsUsed.join(', ')} ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏´‡∏≤‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ó‡∏µ‡πà‡πÄ‡∏Å‡∏µ‡πà‡∏¢‡∏ß‡∏Ç‡πâ‡∏≠‡∏á. `;
    }

    const details = [
      `${toolInfo}‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏ä‡πà‡∏ß‡∏¢‡πÉ‡∏´‡πâ‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡πÅ‡∏ô‡∏ß‡∏Ñ‡∏¥‡∏î‡πÑ‡∏î‡πâ‡∏î‡∏µ‡∏Ç‡∏∂‡πâ‡∏ô ‡πÅ‡∏•‡∏∞‡∏™‡∏≤‡∏°‡∏≤‡∏£‡∏ñ‡∏ô‡∏≥‡πÑ‡∏õ‡∏õ‡∏£‡∏∞‡∏¢‡∏∏‡∏Å‡∏ï‡πå‡πÉ‡∏ä‡πâ‡πÉ‡∏ô‡∏™‡∏ñ‡∏≤‡∏ô‡∏Å‡∏≤‡∏£‡∏ì‡πå‡∏à‡∏£‡∏¥‡∏á‡πÑ‡∏î‡πâ.`,
      `${toolInfo}‡∏´‡∏≤‡∏Å‡∏Ñ‡∏∏‡∏ì‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°‡∏´‡∏£‡∏∑‡∏≠‡∏°‡∏µ‡∏Ñ‡∏≥‡∏ñ‡∏≤‡∏°‡∏≠‡∏∑‡πà‡∏ô‡πÜ ‡∏≠‡∏¢‡πà‡∏≤‡∏•‡∏±‡∏á‡πÄ‡∏•‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏ñ‡∏≤‡∏°‡πÑ‡∏î‡πâ‡πÄ‡∏•‡∏¢.`,
      `${toolInfo}‡∏â‡∏±‡∏ô‡∏´‡∏ß‡∏±‡∏á‡∏ß‡πà‡∏≤‡∏Ñ‡∏≥‡∏ï‡∏≠‡∏ö‡∏ô‡∏µ‡πâ‡∏à‡∏∞‡∏ä‡πà‡∏ß‡∏¢‡πÉ‡∏´‡πâ‡∏Ñ‡∏∏‡∏ì‡πÄ‡∏Ç‡πâ‡∏≤‡πÉ‡∏à‡∏õ‡∏£‡∏∞‡πÄ‡∏î‡πá‡∏ô‡∏ô‡∏µ‡πâ‡πÑ‡∏î‡πâ‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô‡∏Ç‡∏∂‡πâ‡∏ô.`,
      `${toolInfo}‡∏´‡∏≤‡∏Å‡∏°‡∏µ‡∏™‡πà‡∏ß‡∏ô‡πÑ‡∏´‡∏ô‡∏ó‡∏µ‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡∏ä‡∏±‡∏î‡πÄ‡∏à‡∏ô ‡∏Å‡∏£‡∏∏‡∏ì‡∏≤‡πÅ‡∏à‡πâ‡∏á‡πÉ‡∏´‡πâ‡∏â‡∏±‡∏ô‡∏ó‡∏£‡∏≤‡∏ö‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ó‡∏µ‡πà‡∏â‡∏±‡∏ô‡∏à‡∏∞‡πÑ‡∏î‡πâ‡∏≠‡∏ò‡∏¥‡∏ö‡∏≤‡∏¢‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°.`
    ];

    return details[Math.floor(Math.random() * details.length)];
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  public async getUserChats(userId: string): Promise<Chat[]> {
    const chats = await ChatModel.find({ userId })
      .sort({ isPinned: -1, updatedAt: -1 })
      .exec();

    return chats;
  }

  public async deleteChat(chatId: string, userId: string): Promise<boolean> {
    const result = await ChatModel.deleteOne({ _id: chatId, userId });
    const success = result.deletedCount > 0;
    
    if (success) {
      console.log(`üóëÔ∏è Deleted chat session ${chatId}`);
    }
    
    return success;
  }

  public async updateChatName(chatId: string, userId: string, name: string): Promise<Chat | null> {
    const chat = await ChatModel.findOneAndUpdate(
      { _id: chatId, userId },
      { name, updatedAt: new Date() },
      { new: true }
    );

    if (chat) {
      console.log(`‚úèÔ∏è Updated chat name for session ${chatId}`);
    }
    
    return chat;
  }

  public async updateChatPinStatus(chatId: string, userId: string, isPinned: boolean): Promise<Chat | null> {
    const chat = await ChatModel.findOneAndUpdate(
      { _id: chatId, userId },
      { isPinned, updatedAt: new Date() },
      { new: true }
    );

    if (chat) {
      console.log(`üìå Updated pin status for session ${chatId}: ${isPinned}`);
    }
    
    return chat;
  }

  public async clearChatMemory(chatId: string): Promise<void> {
    // Clear messages but keep the chat
    await ChatModel.updateOne(
      { _id: chatId },
      { 
        $set: { 
          messages: [],
          updatedAt: new Date()
        }
      }
    );
    
    console.log(`üßπ Cleared memory for chat session ${chatId}`);
  }

  public getStats(): any {
    return {
      totalChats: 0, // TODO: Implement actual stats
      activeSessions: 0, // TODO: Implement active session count
      totalMessages: 0
    };
  }
}

export const chatService = new ChatService(); 